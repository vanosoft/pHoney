from lex import *
from yacc import *
from lexyac import *
from pprint import pprint as pretty
from random import choice, randint


#

PROLOGUE = '''
; Copyright Chetchasov Ivan (c) 2020-2022.
; Licensed under the MIT License;
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;     https://raw.githubusercontent.com/vanosoft/pHoney/1.9.8a/LICENSE
; Code generated by pHoney code generator.
'''[1:]

class hObj(object):...
class hBody(hObj):...
class hClass(hObj):...
class hComment(hObj):...
class hParam(hObj):...
class hExpr(hObj):...
class hConst(hObj):...
class hVar(hObj):...
class hInter(hObj):...
class hFunc(hObj):...
class hArg(hObj):...
class hAct(hObj):...
class hAssign(hObj):...
class hAccess(hObj):...

class hObj(object):
    #
    __name__: str = "dummy"
    #
    pos: Any
    #
    def __repr__(self):
        return f"honey object \"{self.__name__}\" at {self.pos}"
    pass

class hBody(hObj):
    #
    __name__: str = "body"
    #
    content: list[hObj]
    pass

class hClass(hObj):
    #
    __name__: str = "class"
    #
    name: str
    prnt: str
    private: hAccess
    public: hAccess
    #
    def __init__(s, name: str, prnt: str, pos):
        s.name = name
        s.prnt = prnt
        s.pos  = pos
        s.private = hAccess("private", s.pos)
        s.public = hAccess("public", s.pos)
        pass
    pass

class hComment(hObj):
    #
    __name__: str = "comment"
    #
    value: str
    #
    def __init__(s, val: str, pos: int):
        s.value = val.removeprefix("#").removesuffix("#")
        s.pos = pos
        pass
    pass

class hParam(hObj):
    #
    __name__: str = "param"
    #
    name: str
    #
    def __init__(s, name: str, pos: int):
        s.name = name
        s.pos = pos
        pass
    pass

class hExpr(hObj):
    #
    __name__ = "expression"
    #
    value: YaccNode
    #
    def __init__(s, value, pos):
        s.value = value
        s.pos = pos
        pass
    def __str__(s):
        nl = '\n'
        tb = '\t'
        return f"$expr< {str(s.value).replace(nl, '').replace('----------------', '.').replace(tb, '').replace('    ', '')} @{s.pos} >"
    pass

class hAccess(hObj):
    #
    __name__ = "access"
    #
    name: str
    vars: dict[hVar]
    funcs: dict[hFunc]
    fncs: dict[hFunc]
    #
    def __init__(s, name, pos):
        s.name, s.vars, s.fncs, s.pos = name, {}, {}, pos
        s.funcs = s.fncs
        pass
    pass

class hConst(hObj):
    #
    __name__: str = "const"
    #
    name: str
    typo: str
    valu: hExpr
    #
    def __init__(s, name, typo, valu, pos):
        s.name = name
        s.typo = typo
        s.valu = valu
        s.pos = pos
        pass
    pass

class hVar(hObj):
    #
    __name__ = "variable"
    #
    name: str
    typo: str
    #
    def __init__(s, name, typo, pos):
        s.name = name
        s.typo = typo
        s.pos = pos
        pass
    pass

class hInter(hObj):
    #
    __name__ = "interface"
    #
    name: str
    vars: dict[hVar]
    funcs: dict[hFunc]
    fncs: dict[hFunc]
    pos: int
    #
    def __init__(s, name, vars, funcs, pos):
        s.name, s.vars, s.funcs, s.fncs, pos = name, vars, funcs, funcs, pos
        s.pos = pos
        pass
    pass

class hAct(hObj):
    #
    __name__ = "action"
    #
    typo: str
    data: hAssign
    #
    def __init__(s, typo, data, pos):
        s.typo, s.data, s.pos = typo, data, pos
        pass
    pass

class hFunc(hObj):
    #
    __name__: str = "function"
    #
    name: str
    typo: str
    args: list[hArg]
    work: list[hAct]
    #
    def __init__(s, name, typo, args, pos):
        s.name, s.typo, s.args = name, typo, args
        s.pos = pos
        pass
    pass

class hArg(hObj):
    #
    __name__: str = "argument"
    #
    name: str
    typo: str
    #
    def __init__(s, name, typo, pos):
        s.name, s.typo, s.pos = name, typo, pos
        pass
    pass

class hAssign(hObj):
    #
    __name__ = "assign"
    #
    name: str
    valu: hExpr
    #
    def __init__(s, name, valu, pos):
        s.name, s.valu, s.pos = name, valu, pos
        pass
    pass

WALK_DEEPER = """for p in n:\n\tif type(p) is YaccNode:\n\t\ts.walk(p, code)"""

class TransError(Exception):
    def __init__(self, *args: object):
        super().__init__(*args[:1])
        self.pops = args[1]
        pass
    pass

class Trans:
    root: bool = 0
    clas: bool = 0
    intr: bool = 0
    priv: bool = 0
    publ: bool = 0
    mmbr: bool = 0
    func: bool = 0
    data_classes: dict[str,hClass] = {"Base":hClass("Base", "<external>", -1)}
    data_coments: list[hComment] = []
    data_paramts: list[hParam] = []
    data_interfs: dict[str,hInter] = {}
    data_constns: dict[str,hConst] = {}
    data_varabls: dict[str,hVar] = {}
    data_working: list[hAct] = []
    data_functns: dict[str,hFunc] = {}
    data_akafunc: str = 'none'
    currentclass: str = 'none'
    currentfuncn: str = 'none'
    currentcycle: int = 0
    lastobjectid: int = 0
    #
    def __init__(s):
        pass
    def pregen(s):
        nl, tb = '\n', '\t'
        ret = ""
        ret += f"format PE{'64' if 'bits' not in s.data_paramts else s.data_paramts['bits']}\n"
        ret += f"entry {s.data_akafunc if s.data_akafunc != 'none' else '__hny_auto_main'}\n\n"
        ret += f"section '.rodata' data readable\n; constants\n"
        for i in s.data_constns:
            ret += f"{s.data_constns[i].typo} {s.data_constns[i].name}, {s.data_constns[i].valu}\n"
            pass
        ret += f"\nsection '.bsdata' data readable writable\n; variables\n"
        for i in s.data_varabls:
            ret += f"{s.data_varabls[i].typo} {s.data_varabls[i].name} none\n"
            pass
        ret += f"\nsection '.stdata' data readable\n; classes\n\n"
        for i in s.data_classes:
            ret += f"; {s.data_classes[i].name} <- {s.data_classes[i].prnt}\n"
            ret += f"\n; private variables\n" if s.data_classes[i].private.vars != [] else f"\n; no public variables\n"
            for j in s.data_classes[i].private.vars:
                ret += f"{j.typo} {j.name} none"
                pass
            ret += f"\n; private functions\n" if s.data_classes[i].private.funcs != [] else f"\n; no private functions\n"
            for j in s.data_classes[i].private.funcs:
                ret += f"func {j.name}"
                pass
            ret += f"\n; public variables\n" if s.data_classes[i].public.vars != [] else f"\n; no public variables\n"
            for j in s.data_classes[i].public.vars:
                ret += f"{j.typo} {j.name} none"
                pass
            ret += f"\n; public functions\n" if s.data_classes[i].public.funcs != [] else f"\n; no public functions\n"
            for j in s.data_classes[i].public.funcs:
                ret += f"func {j.name}"
                pass
            ret += f"\n\n"
            pass
        ret += f"section '.text' code readable executable\n"
        if s.data_akafunc == 'none':
            ret += "__hny_auto_main:\n"
            for i in s.data_working:
                ret += f"work ${i.typo} @{i.pos} < {str(i.data).replace(nl, '').replace(tb, '').replace('    ', '').replace('----------------','::')} >\n"
                pass
            pass
        return ret
    def dump(s):
        return {"classes": {**s.data_classes}, "comments": [*s.data_coments], "parameters": [*s.data_paramts], "interfaces": {**s.data_interfs},
        "consts": {**s.data_constns}, "variables": {**s.data_varabls}, "work": [*s.data_working], "functions": {**s.data_functns}, "aka": s.data_akafunc}
    def walk(s, node: YaccNode, code: str):
        n = node.par
        t = node.typ
        l = len(code[:node.nod.start_position].split("\n"))
        #
        print(f"walk found \"{t}\" at line {l}")
        #
        if t == "root":
            s.root = 1
            exec(WALK_DEEPER)
            pass
        if t == "comment":
            print(f"\t\tcomment string: \"{node.par[0]}\"")
            s.data_coments += [hComment(n[0].removeprefix("#"), l)]
            pass
        if t == "param":
            s.data_paramts.append(hParam(n[0], l))
            print(f"\t\tproperty: \"{node.par[0]}\"")
            pass
        if t == "aka":
            s.data_akafunc = n[0]
            print(f"\t\taka function: {node.par[0]}")
            pass
        if t == "const":
            print(f"\t\tconstant name={n[0]} type={n[1]} value={n[2]}")
            s.data_constns[n[0]] = hConst(n[0], n[1], hExpr(n[2], l), l)
            pass
        if t == "class":
            s.data_classes[n[0]] = hClass(n[0],n[1],l)
            s.root = 0
            s.clas = 1
            s.currentclass = n[0]
            print(f"\t\tclass name={n[0]} parent={n[1]} body=...")
            exec(WALK_DEEPER)
            s.root = 1
            s.clas = s.priv = s.publ = 0
            pass
        if t == "member":
            print(f"\t\tmember define = {n[0]}")
            if s.root or not s.intr:
                print(f"Error at {l}: members must be in interfaces")
                raise SystemExit(1)
            s.mmbr = 1
            exec(WALK_DEEPER)
            s.mmbr = 0
            pass
        if t == "define":
            if s.root:
                s.data_varabls[n[0]] = hVar(n[0], n[1], l)
                pass
            elif s.clas:
                if  not (s.priv or s.publ):
                    print(f"Error at {l}: class field must contain access rights (private/public)")
                    raise SystemExit(1)
                if s.priv:
                    s.data_classes[s.currentclass].private.vars[n[0]] = hVar(n[0], n[1], l)
                    pass
                if s.publ:
                    s.data_classes[s.currentclass].public.vars[n[0]] = hVar(n[0], n[1], l)
                    pass
                pass
            elif s.intr:
                if s.mmbr:
                    s.data_interfs[s.currentclass].vars[n[0]] = hVar(n[0], n[1], l)
                    pass
                else:
                    print(f"Error at {l}: definition in interface must be a member")
                    raise SystemExit(1)
                pass
            else:
                print(f"Error at {l}: internal error")
                raise SystemExit(2)
            pass
        if t == "assign":
            print("assign")
            if not(s.root or s.func):
                print(f"Error at {l}: work expected only in root and functions/methods")
                raise SystemExit(1)
            elif s.root:
                print("in root")
                # root::assign
                s.data_working.append(hAct('assign', {'name':n[0],'value':n[1]}, l))
                pass
            elif s.func:
                if s.clas:
                    if  not (s.priv or s.publ):
                        print(f"Error at {l}: work mustn't be in class purely")
                        raise SystemExit(1)
                    if s.publ:
                        # class.public.func::assign
                        s.data_classes[s.currentclass].public.funcs[s.currentfuncn].work.append(hAct('assign', {'name':n[0],'value':n[1]}, l))
                        pass
                    elif s.priv:
                        # class.private.func::assign
                        s.data_classes[s.currentclass].private.funcs[s.currentfuncn].work.append(hAct('assign', {'name':n[0],'value':n[1]}, l))
                        pass
                    pass
                else:
                    # root.func::assign
                    s.data_functns[s.currentfuncn].work.append(hAct('assign', {'name':n[0], 'value':n[1]}, l))
                    pass
                pass
            else:
                print(f"Error at {l}: unexpected place for work")
                raise SystemExit(1)
            pass
        if t == "adefine":
            exec(WALK_DEEPER)
            pass
        if t == "private":
            if s.priv:
                print(f"Error at {l}: private can be in class, not private")
                raise SystemExit(1)
            if s.publ:
                print(f"Error at {l}: private cannot be in public")
                raise SystemExit(1)
            if s.root:
                print(f"Error at {l}: private cannot be in root")
                raise SystemExit(1)
            if s.intr:
                print(f"Error at {l}: private cannot be in interface")
                raise SystemExit(1)
            if  not s.clas:
                print(f"Error at {l}: private must be in class")
                raise SystemExit(1)
            if ( not s.root) and ( not s.publ) and ( not s.priv) and ( not s.intr) and (s.clas):
                s.priv = 1
                pass
            exec(WALK_DEEPER)
            s.priv = 0
            pass
        if t == "public":
            if s.publ:
                print(f"Error at {l}: public can be in class, not public")
                raise SystemExit(1)
            if s.priv:
                print(f"Error at {l}: public cannot be in private")
                raise SystemExit(1)
            if s.root:
                print(f"Error at {l}: public cannot be in root")
                raise SystemExit(1)
            if s.intr:
                print(f"Error at {l}: public cannot be in interface")
                raise SystemExit(1)
            if  not s.clas:
                print(f"Error at {l}: public must be in class")
                raise SystemExit(1)
            if ( not s.root) and ( not s.publ) and ( not s.priv) and ( not s.intr) and (s.clas):
                s.publ = 1
                pass
            exec(WALK_DEEPER)
            s.publ = 0
            pass
        if t == "function":
            if s.root:
                s.data_functns[n[0]] = hFunc(n[0],n[2],n[1],l)
                pass
            elif s.clas and (s.priv or s.publ):
                if s.priv:
                    s.data_classes[s.currentclass].private.funcs[n[0]] = hFunc(n[0],n[2],n[1],l)
                    pass
                elif s.publ:
                    s.data_classes[s.currentclass].public.funcs[n[0]] = hFunc(n[0],n[2],n[1],l)
                    pass
                pass
            else:
                print(f"Error at {l}: function declaration must be in root or class private/public")
                raise SystemExit(1)
            s.func = 1
            root = s.root
            s.root = 0
            exec(WALK_DEEPER)
            s.func = 0
            s.root = root
            del root
            pass
        if t == "return":
            if  not (s.func or s.root):
                print(f"Error at {l}: return must be in root or function")
                raise SystemExit(1)
            elif s.clas and (s.priv or s.publ):
                if s.priv:
                    s.data_classes[s.currentclass].private.work.append(hAct('return', {'data':n[0]},l))
                    pass
                elif s.publ:
                    s.data_classes[s.currentclass].public.work.append(hAct('return',{'data':n[0]},l))
                    pass
                pass
            elif s.func and ( not s.clas):
                s.data_functns[n[0]].work.append(hAct('return',{'data':n[0]},l))
                pass
            elif (s.root) and ( not s.func) and ( not s.clas) and ( not (s.priv or s.publ)):
                s.data_working.append(hAct('return',{'data':n[0]},l))
                pass
            pass
        if t == "call":
            if  not (s.func or s.root):
                print(f"Error at {l}: return must be in root or function")
                raise SystemExit(1)
            elif s.clas and (s.priv or s.publ) and s.func:
                if s.priv:
                    s.data_classes[s.currentclass].private.work.append(hAct('call', {'name':n[0],'args':n[1]},l))
                    pass
                if s.publ:
                    s.data_classes[s.currentclass].public.work.append(hAct('call', {'name':n[0],'args':n[1]},l))
                    pass
                pass
            elif s.func and ( not s.clas):
                s.data_functns[n[0]].work.append(hAct('call', {'name':n[0],'args':n[1]},l))
                pass
            elif (s.root) and ( not s.func) and ( not s.clas) and ( not (s.priv or s.publ)):
                s.data_working.append(hAct('call', {'name':n[0],'args':n[1]},l))
                pass
            pass
        if t == "interface":
            s.intr = 1
            s.root = 0
            s.currentclass = n[0]
            s.data_interfs[n[0]] = hInter(n[0],{},{},l)
            exec(WALK_DEEPER)
            s.intr = 0
            s.root = 1
            pass
        if t == "block":
            exec(WALK_DEEPER)
            pass
        if t == "for":
            if  not (s.func or s.root):
                print(f"Error at {l}: for must be in root or function")
                raise SystemExit(1)
            elif s.clas and (s.priv or s.publ) and s.func:
                if s.priv:
                    s.data_classes[s.currentclass].private.funcs[s.currentfuncn].work.append(hAct('for', {'from':n[0],'to':n[1],'by':n[2],"id":s.lastobjectid},l))
                    pass
                if s.publ:
                    s.data_classes[s.currentclass].public.funcs[s.currentfuncn].work.append(hAct('for', {'from':n[0],'to':n[1],'by':n[2],"id":s.lastobjectid},l))
                    pass
                pass
            elif s.func and ( not s.clas):
                s.data_functns[n[0]].work.append(hAct('for', {'from':n[0],'to':n[1],'by':n[2],"id":s.lastobjectid},l))
                pass
            elif (s.root) and ( not s.func) and ( not s.clas) and ( not (s.priv or s.publ)):
                s.data_working.append(hAct('for', {'from':n[0],'to':n[1],'by':n[2],"id":s.lastobjectid},l))
                pass
            curid = s.lastobjectid
            s.lastobjectid += 1
            exec(WALK_DEEPER)
            if  not (s.func or s.root):
                print(f"Error at {l}: for must be in root or function")
                raise SystemExit(1)
            elif s.clas and (s.priv or s.publ) and s.func:
                if s.priv:
                    s.data_classes[s.currentclass].private.funcs[s.currentfuncn].work.append(hAct('for_end', {'from':n[0],'to':n[1],'by':n[2],"id":curid},l))
                    pass
                if s.publ:
                    s.data_classes[s.currentclass].public.funcs[s.currentfuncn].work.append(hAct('for_end', {'from':n[0],'to':n[1],'by':n[2],"id":curid},l))
                    pass
                pass
            elif s.func and ( not s.clas):
                s.data_functns[n[0]].work.append(hAct('for_end', {'from':n[0],'to':n[1],'by':n[2],"id":curid},l))
                pass
            elif (s.root) and ( not s.func) and ( not s.clas) and ( not (s.priv or s.publ)):
                s.data_working.append(hAct('for_end', {'from':n[0],'to':n[1],'by':n[2],"id":s.curid},l))
                pass
            del curid
            pass
        if t == "while":
            if  not (s.func or s.root):
                print(f"Error at {l}: while must be in root or function")
                raise SystemExit(1)
            elif s.clas and (s.priv or s.publ) and s.func:
                if s.priv:
                    s.data_classes[s.currentclass].private.funcs[s.currentfuncn].work.append(hAct('while', {'cond':n[0],"id":s.lastobjectid},l))
                    pass
                if s.publ:
                    s.data_classes[s.currentclass].public.funcs[s.currentfuncn].work.append(hAct('while', {'cond':n[0],"id":s.lastobjectid},l))
                    pass
                pass
            elif s.func and ( not s.clas):
                s.data_functns[n[0]].work.append(hAct('while', {'cond':n[0],"id":s.lastobjectid},l))
                pass
            elif (s.root) and ( not s.func) and ( not s.clas) and ( not (s.priv or s.publ)):
                s.data_working.append(hAct('while', {'cond':n[0],"id":s.lastobjectid},l))
                pass
            curid = s.lastobjectid
            s.lastobjectid += 1
            exec(WALK_DEEPER)
            if  not (s.func or s.root):
                print(f"Error at {l}: for must be in root or function")
                raise SystemExit(1)
            elif s.clas and (s.priv or s.publ) and s.func:
                if s.priv:
                    s.data_classes[s.currentclass].private.funcs[s.currentfuncn].work.append(hAct('while_end', {'cond':n[0],"id":curid},l))
                    pass
                if s.publ:
                    s.data_classes[s.currentclass].public.funcs[s.currentfuncn].work.append(hAct('while_end', {'cond':n[0],"id":curid},l))
                    pass
                pass
            elif s.func and ( not s.clas):
                s.data_functns[n[0]].work.append(hAct('while_end', {'cond':n[0],"id":curid},l))
                pass
            elif (s.root) and ( not s.func) and ( not s.clas) and ( not (s.priv or s.publ)):
                s.data_working.append(hAct('while_end', {'cond':n[0],"id":curid},l))
                pass
            del curid
            pass
        return None
    pass
